<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <link rel="shortcut icon" href="/images/avatar.png" type="image/x-icon" />
    <title>
        
            算法题型 Leetcode |
         
        编舟
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/solid.min.css">

     
    
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXXXX"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-XXXXXXXXXXXX');
        </script>
    


<meta name="generator" content="Hexo 7.0.0"></head>

<body>
    <div class="body-container">
        <div class="header-wrapper"><header>
    <div class="header-container">
        <div class="header-menu-list">
            <ul>
            
                <li>
                    <a href="/">Home</a>
                </li>
            
                <li>
                    <a href="/about">About</a>
                </li>
            
            </ul>
        </div>
    </div>
</header>
</div>
        <div class="main-wrapper"><main>
    <div class="main-container">
        <div class="post-details">
            
            <div class="post-title">
                <h1>算法题型 Leetcode</h1>
            </div>
            <div class="post-meta">
                <i class="fa-solid fa-clock"></i>&nbsp;<span class="post-date">2024/01/03</span>
            </div>
            
            <div class="post-content">
                <p>面试经典150题 <a target="_blank" rel="noopener" href="https://leetcode.cn/studyplan/top-interview-150/">https://leetcode.cn/studyplan/top-interview-150/</a></p>
<h1 id="数组-字符串"><a href="#数组-字符串" class="headerlink" title="数组&#x2F;字符串"></a>数组&#x2F;字符串</h1><h2 id="合并两个有序数组-简单"><a href="#合并两个有序数组-简单" class="headerlink" title="合并两个有序数组 &#x2F; 简单"></a>合并两个有序数组 &#x2F; 简单</h2><p>双指针</p>
<ul>
<li>两个指针分别指向数组第一个元素</li>
<li>比较小的元素，存入到新数组待存储位置，并且指针指向下一个元素</li>
</ul>
<p>伪代码</p>
<ol>
<li>开辟一个新数组，容量是两个旧数组容量之和</li>
<li>两个指针分别指向数组第一个元素</li>
<li>比较指针指向元素的大小，小的指针指向的元素存入新数组，小的指针指向下个位置</li>
<li>重复3过程，直到任意一个指针指向的位置没有值</li>
<li>另一个还有值的元素依次存到新数组中</li>
</ol>
<p>注意</p>
<ul>
<li>数组的指针其实就是位置号</li>
<li>最优解法是逆向双指针</li>
</ul>
<h2 id="移除元素-简单"><a href="#移除元素-简单" class="headerlink" title="移除元素 &#x2F; 简单"></a>移除元素 &#x2F; 简单</h2><p>双指针</p>
<ul>
<li>左指针指向元素待存储位置</li>
<li>用右指针遍历数组，挑选不等于移除元素的元素，存储到待存储位置</li>
</ul>
<p>伪代码</p>
<ol>
<li>左右指针都指向数组第一个元素，左指针代表待存储位置，右指针代表当前查询元素</li>
<li>如果右指针和待移除元素不相同，将右指针指向的值存入到左指针位置，左指针位置移到下一个</li>
<li>右指针移到下一个，重复2过程，直到右指针指向的位置没有值</li>
<li>左指针的位置即新数组的大小</li>
</ol>
<h2 id="删除有序数组中的重复项-简单"><a href="#删除有序数组中的重复项-简单" class="headerlink" title="删除有序数组中的重复项 &#x2F; 简单"></a>删除有序数组中的重复项 &#x2F; 简单</h2><p>双指针</p>
<ul>
<li>左指针指向待存储位置，也就是第二个元素（第一个元素肯定不用变）</li>
<li>右指针遍历数组，挑选和左指针左边位置值不同的元素，存储到待存储位置</li>
</ul>
<p>伪代码</p>
<ol>
<li>如果数组只有一个或以下元素，返回原大小</li>
<li>左指针指向第二个元素，右指针也指向第二个元素。左指针代表待存储位置，右指针代表当前查询元素</li>
<li>比较左指针前一个元素和右指针查询元素，如果不同，将右指针元素存入左指针待存储位置，左指针移到下一个</li>
<li>右指针移到下一个，重复3过程，直到右指针指向的位置没有值</li>
<li>左指针的位置即新数组的大小</li>
</ol>
<h2 id="删除有序数组中的重复项2-中等"><a href="#删除有序数组中的重复项2-中等" class="headerlink" title="删除有序数组中的重复项2 &#x2F; 中等"></a>删除有序数组中的重复项2 &#x2F; 中等</h2><p>双指针</p>
<ul>
<li>左指针指向待存储位置，也就是第三个元素（前两个元素肯定不用变）</li>
<li>右指针遍历数组，挑选和左指针左侧的左侧位置值不同的元素，存储到待存储位置</li>
</ul>
<p>删除有序数字中的重复项k 通用解法</p>
<ul>
<li>如果数组只有k项或以下元素，返回原大小</li>
<li>左指针指向待存储位置，即k位置(第K+1个位置)，右指针也指向k位置</li>
<li>用右指针遍历数组，如果右指针指向的值和左指针向左偏移k位置的值不同，就可以把右指针的值存入到左指针待存位置</li>
<li>左指针的位置即新数组的大小</li>
</ul>
<h2 id="多数元素-简单"><a href="#多数元素-简单" class="headerlink" title="多数元素 &#x2F; 简单"></a>多数元素 &#x2F; 简单</h2><p>摩尔投票</p>
<ul>
<li>众数指的是超过半数的数，即要寻找的数</li>
<li>众数 +1，非众数 -1。所有数累加肯定大于0</li>
<li>如果前a个数等于0。剩下的数累加必须大于0才能满足上面的条件。而+1的数必须还是众数才能满足。由次推出众数在剩余元素中还是众数</li>
<li>假设第一个数是众数<ul>
<li>如果不正确，在循环结束前，真正的众数一定能把值减到0。到下个流程</li>
<li>如果正确，一直循环到结束即确定了众数。如果没能循环到结束，即中途再次被减到0。到下个流程</li>
</ul>
</li>
<li>减到0之后，说明前面的数作废了。问题简化到在剩下的数中寻找众数。继续重复上一个过程</li>
<li>本质上，假设第一个数为众数后会出现三种情况<ul>
<li>假设错误，会被真正的众数减到0，用剩余的数组重新进入假设</li>
<li>假设正确，但是被非众数减到0，用剩余的数组重新进入假设</li>
<li>假设正确，直到循环结束。只有这种出循环的方式</li>
</ul>
</li>
</ul>
<p>伪代码</p>
<ul>
<li>假设第一个数是众数</li>
<li>遍历数组，如果是众数+1，否则-1</li>
<li>如果累加的结果是0。下一次执行的时候重新假设第一个数是众数</li>
<li>遍历结束时的众数即为结果。</li>
</ul>
<h2 id="轮转数组-中等"><a href="#轮转数组-中等" class="headerlink" title="轮转数组 &#x2F; 中等"></a>轮转数组 &#x2F; 中等</h2><p>三次反转 + 双指针</p>
<ul>
<li>先反转数组</li>
<li>在从需要轮转的位置拆分数组，两边分别反转</li>
</ul>
<p>伪代码 (假设向右轮转k个位置，数组长度是n)</p>
<ol>
<li>k对n取余数 (k % n)</li>
<li>双指针分别指向数组首尾</li>
<li>交换首位指针指向的元素，首指针移动到下个位置，尾指针移动到上个位置</li>
<li>重复过程3，直到首指针大于等于尾指针</li>
<li>首指针指向数组首，尾指针指向k-1，执行过程3,4</li>
<li>首指针指向k，尾指针指向数组尾，执行过程3,4</li>
</ol>
<h2 id="买卖股票的最佳时机-简单"><a href="#买卖股票的最佳时机-简单" class="headerlink" title="买卖股票的最佳时机 &#x2F; 简单"></a>买卖股票的最佳时机 &#x2F; 简单</h2><p>动态规划</p>
<ul>
<li>设dp(i-1)是i-1天前的最高利润</li>
<li>dp(i)的值只有两种可能性<ul>
<li>等于dp(i-1)</li>
<li>等于dp(i) - 前i天中的最低成本<ul>
<li>前i天的最低成本是可以在遍历中一直保存的，本质上就是存储最小值</li>
</ul>
</li>
</ul>
</li>
<li>所有dp(i)中的最大值即为结果</li>
</ul>
<p>伪代码</p>
<ol>
<li>设置最低成本为无穷大，设置最高利润为0</li>
<li>比较当前成本和最低成本，较小的作为最低成本</li>
<li>当日交易的最高利润等于当日价格减去历史最低成本，和历史最高利润对比，较大的作为最高利润</li>
<li>重复过程2,3</li>
<li>返回最高利润</li>
</ol>
<h2 id="买卖股票的最佳时机2-中等"><a href="#买卖股票的最佳时机2-中等" class="headerlink" title="买卖股票的最佳时机2 &#x2F; 中等"></a>买卖股票的最佳时机2 &#x2F; 中等</h2><p>贪心算法</p>
<ul>
<li>遍历数组</li>
<li>用当前元素减前一个元素，计算所有的差，累加所有大于0的差</li>
</ul>
<p>伪代码</p>
<ol>
<li>指针指向第二个元素，当前最高利润是0</li>
<li>指针指向的值减去指针前一个位置的值，差大于0则累加到最高利润中</li>
<li>指针移动到下个位置，重复过程2</li>
<li>返回最高利润</li>
</ol>
<p>注意</p>
<ul>
<li>也可以用动态规划解决，更通用，但是更复杂</li>
</ul>
<h2 id="跳跃游戏-中等"><a href="#跳跃游戏-中等" class="headerlink" title="跳跃游戏 &#x2F; 中等"></a>跳跃游戏 &#x2F; 中等</h2><p>返回能否跳到最后位置</p>
<p>动态优化</p>
<ul>
<li>本质上这道题就是找所有格子能跳到的最远位置是否大于等于最后一个下标</li>
<li>设dp(i-1)是i-1个点前的最远跳跃位置</li>
<li>dp(i)的值的可能性，都是两种可能性中的最大值<ul>
<li>dp(i-1)</li>
<li>i + nums[i]</li>
</ul>
</li>
</ul>
<p>伪代码</p>
<ol>
<li>指针k指向全局能跳到的最远位置，指针i指向当前位置</li>
<li>指针指向位置+能跳距离&#x3D;从当前位置跳的最远位置</li>
<li>和全局能跳的最远位置对比，大的作为全局最远位置</li>
<li>重复循环，直到跳到最后一个下标，或者指针指向的位置超过了最远位置</li>
<li>如果跳到了最后一个下标，返回成功</li>
</ol>
<h2 id="跳跃游戏2-中等"><a href="#跳跃游戏2-中等" class="headerlink" title="跳跃游戏2 &#x2F; 中等"></a>跳跃游戏2 &#x2F; 中等</h2><p>返回最小跳跃数，题目保证可以跳到最后位置</p>
<p>贪心算法 (每次都找局部最优解，最后达到全局最优)</p>
<ul>
<li>本质上是在计算每次跳跃之后，能跳到的区间范围，作为下次的起跳范围，一旦区间范围的右侧到达最后一个位置，就成功了</li>
<li>以最小跳跃数，逐步增加覆盖范围，一旦覆盖到终点就成功了</li>
</ul>
<p>注意<br>贪心算法，怎么保证全局最优</p>
<ul>
<li>问题需要满足贪心选择性质<ul>
<li>最优子结构，即问题的最优解可以通过子问题的最优解来构造，即全局最优解包含子问题最优解</li>
</ul>
</li>
<li>问题无后效性，即当前的选择不会影响未来的决策。一旦做出选择就不需要回头修改。</li>
</ul>
<p>贪心算法，动态规划，回溯法，分治法的关系</p>
<ul>
<li>贪心算法和动态规划都是考虑局部最优解的组合，贪心算法是动态规划的一个特例，当满足贪心选择性质时，可以使用贪心算法<ul>
<li>动态规划：最优子结构</li>
<li>贪心算法：最优子结构 + 贪心选择性质<ul>
<li>最优子结构：一个问题的最优解包含了其子问题的最优解<ul>
<li>找到最优解的选择：对于当前问题，找到一种选择使得问题的最优解包含子问题的最优解 &#x2F;&#x2F;这部最难</li>
<li>递归地解决子问题：对每个子问题，递归的应用相同的问题，</li>
<li>合并子问题的解：将子问题的最优解合并或组合，得到原问题的最优解</li>
</ul>
</li>
<li>贪心选择性质：问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到</li>
</ul>
</li>
</ul>
</li>
<li>回溯法是一种更一般化算法，不要求具有最优子结构，尝试所有可能，在搜索过程中进行剪枝<ul>
<li>回溯法：不要求最优子结构</li>
<li>回溯法本质是暴力搜索</li>
<li>回溯是递归的副产品，只要由递归就会由回溯</li>
<li>为了让回溯法高效一点，可以加一些剪枝操作，但改变不了回溯法的穷举本质</li>
<li>既然回溯法不高效，为什么用它 -&gt; 因为没得选，一些问题能暴力搜出来就不错了，顶多再剪枝一下，还没有高效的解法</li>
<li>回溯法解决的问题都可以抽象为树形结构 (怪不得叫剪枝..)</li>
<li>遍历树形结构就要由终止条件，一般是搜索到叶子节点</li>
<li>回溯法模板<pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span> &#123;
    <span class="hljs-keyword">if</span> (终止条件) &#123;
        存放结果;
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-keyword">for</span> (选择: 本层集合中的元素) &#123;
        处理节点；
        backtracing(路径， 选择列表);
        回溯，撤销处理结果
    &#125;
&#125;</code></pre></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1736551">https://cloud.tencent.com/developer/article/1736551</a></li>
</ul>
</li>
<li>分治法，将问题分解成若干个相互独立的子问题，递归求解，最后合并</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rond/archive/2012/07/07/2580737.html">https://www.cnblogs.com/rond/archive/2012/07/07/2580737.html</a></p>
<p>突然意识到经典算法问题的解决方案其实很有限</p>
<ul>
<li>问题拆分成独自子问题 -&gt; 分治法</li>
<li>问题拆分成嵌套子问题 -&gt; 动态规划<ul>
<li>子问题最优解可以决定整体最优解 -&gt; 贪心算法</li>
</ul>
</li>
<li>以上方案都不行，以树形结构递归搜索问题解空间，进行试错，本质是暴力搜索+剪枝 -&gt; 回溯法</li>
</ul>
<h2 id="H指数-中等"><a href="#H指数-中等" class="headerlink" title="H指数 &#x2F; 中等"></a>H指数 &#x2F; 中等</h2><p>满足h个数大于h的最大值</p>
<p>二分查找(第二种模板) <a target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/31/">https://www.acwing.com/blog/content/31/</a></p>
<ul>
<li>本质是查找出0到n(h最大可能值)之间符合条件的最大值</li>
</ul>
<p>代码分析</p>
<pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cs)</span> &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cs.length;

        <span class="hljs-comment">//设定初始边界，表示要在0和n的闭区间内寻找</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n;

        <span class="hljs-keyword">while</span> (l &lt; r) &#123;

            <span class="hljs-comment">//+1 这步是为了防止死循环，确保偶数个的时候，mid值选在中点或右侧</span>
            <span class="hljs-comment">//因为当前查找的是最大满足的值</span>
            <span class="hljs-comment">//二分查找最后结束前会有两种情况，剩下一个值</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;

            <span class="hljs-comment">//满足条件的话，就继续查找 [mid, r]</span>
            <span class="hljs-comment">//标准的二分查找，一般是设置 l = mid + 1，一旦查找过mid满足即成功，不满足就会放弃mid，而从mid+1开始</span>
            <span class="hljs-comment">//但是当前查找的是满足的最大值，即便成功，也要在它及它以上的区间继续寻找</span>
            <span class="hljs-comment">//如果mid仍然按照之前的 mid = (l + r) / 2，当 r = l + 1时 mid = l + 0.5 下取整成 l，会陷入死循环，所以要采用上取整的方式</span>
            <span class="hljs-comment">//也就是check成功之后的条件 l = mid 决定了，上面的mid算法要用上取整，避免 mid = l 的情况出现</span>
            <span class="hljs-keyword">if</span> (check(cs, mid)) l = mid;

            <span class="hljs-comment">//不满足条件的话，继续查找 [l, mid-1]</span>
            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">return</span> r;
    &#125;

    <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cs, <span class="hljs-type">int</span> mid)</span> &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : cs) <span class="hljs-keyword">if</span> (i &gt;= mid) ans++;
        <span class="hljs-keyword">return</span> ans &gt;= mid;
    &#125;
&#125;</code></pre>

<h2 id="O-1-时间插入、删除和获取随机元素-中等"><a href="#O-1-时间插入、删除和获取随机元素-中等" class="headerlink" title="O(1)时间插入、删除和获取随机元素 &#x2F; 中等"></a>O(1)时间插入、删除和获取随机元素 &#x2F; 中等</h2><p>哈希表 &#x2F; 数组</p>
<ul>
<li>插入和删除 O(1) 需要使用哈希表</li>
<li>获取随机元素，需要用到数据</li>
<li>删除的时候，把数组末尾的插入到删除位置<ul>
<li>删除的时候，从哈希表中通过值查找在数组中的位置</li>
<li>用数组的最后一位覆盖删除的值</li>
</ul>
</li>
</ul>
<h2 id="除自身以外数组的乘机-中等"><a href="#除自身以外数组的乘机-中等" class="headerlink" title="除自身以外数组的乘机 &#x2F; 中等"></a>除自身以外数组的乘机 &#x2F; 中等</h2><p>前缀积 * 后缀积</p>
<ul>
<li>一次遍历，可以得到前缀积的数组</li>
<li>一次遍历，可以得到后缀积的数组</li>
<li>最后一次遍历，结果就等于前缀积和后缀积的乘积</li>
</ul>
<h2 id="加油站-中等"><a href="#加油站-中等" class="headerlink" title="加油站 &#x2F; 中等"></a>加油站 &#x2F; 中等</h2><ul>
<li>从x出发最远到y加油站，那么从x到y之间的任意一站出发都不可能超过y加油站。因为x出发的时候，途中的任意一站汽油都大于等于0，如果把这站当作出发点，油会从0开始，到的站不可能更远</li>
</ul>
<p>伪代码</p>
<ul>
<li>指针指向第一个点，作为起点指针</li>
<li>从起点指针所指位置开始，依次移动到下一位，累加总油量和总耗量，记录走过的站数<ul>
<li>当总耗量大于总油量的时候，中断，从下一站出发，状态重置重新出发</li>
<li>当记录的站数等于总站数的时候，返回成功</li>
<li>遍历到最后一个位置，返回失败</li>
</ul>
</li>
</ul>
<h2 id="分发糖果-困难"><a href="#分发糖果-困难" class="headerlink" title="分发糖果 &#x2F; 困难"></a>分发糖果 &#x2F; 困难</h2><h2 id="接雨水-困难"><a href="#接雨水-困难" class="headerlink" title="接雨水 &#x2F; 困难"></a>接雨水 &#x2F; 困难</h2><h2 id="罗马数字转整数-简单"><a href="#罗马数字转整数-简单" class="headerlink" title="罗马数字转整数 &#x2F; 简单"></a>罗马数字转整数 &#x2F; 简单</h2><ul>
<li>字符串遍历</li>
<li>如果下一位罗马字比当前位代表的数字大，就减去当前位</li>
<li>否则，加上当前位</li>
</ul>
<h2 id="整数转罗马字-中等"><a href="#整数转罗马字-中等" class="headerlink" title="整数转罗马字 &#x2F; 中等"></a>整数转罗马字 &#x2F; 中等</h2><p>贪心算法</p>
<ul>
<li>类似于找零钱，每次都给最大面值的</li>
<li>列举出所有罗马字符的对应关系数组 nums -&gt; romans</li>
<li>由大到小遍历nums中的元素num<ul>
<li>只要value&gt;num，就用value-num，并把对应roman拼接到结果字符串中</li>
<li>重复执行上面的步骤</li>
<li>否则遍历偏移 +1</li>
</ul>
</li>
</ul>
<h2 id="最后一个单词的长度"><a href="#最后一个单词的长度" class="headerlink" title="最后一个单词的长度"></a>最后一个单词的长度</h2>
            </div>
        </div>
    </div>
</main>

<script src="https://utteranc.es/client.js"
    repo="owner/repo"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  

</div>
        <div class="footer-wrapper"><footer>
    <div class="footer-container">
        <div class="footer-meta">
            
                <div class="footer-meta-copyright">
                    &copy; 2024 taninety.
                </div>
            
            
                <div class="footer-meta-licenese">
                    Licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA 4.0</a>
                </div>
            
            
                <div class="footer-meta-rss">
                    <a href="/atom.xml"><i class="fa-solid fa-rss"></i></a>
                </div>
            
        </div>
    </div>
</footer>
</div>
    </div>
</body>
</html>
