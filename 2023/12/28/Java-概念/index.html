<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <link rel="shortcut icon" href="/images/avatar.png" type="image/x-icon" />
    <title>
        
            Java 概念 |
         
        编舟
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/solid.min.css">

     
    
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXXXX"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-XXXXXXXXXXXX');
        </script>
    


<meta name="generator" content="Hexo 7.0.0"></head>

<body>
    <div class="body-container">
        <div class="header-wrapper"><header>
    <div class="header-container">
        <div class="header-menu-list">
            <ul>
            
                <li>
                    <a href="/">Home</a>
                </li>
            
                <li>
                    <a href="/about">About</a>
                </li>
            
            </ul>
        </div>
    </div>
</header>
</div>
        <div class="main-wrapper"><main>
    <div class="main-container">
        <div class="post-details">
            
            <div class="post-title">
                <h1>Java 概念</h1>
            </div>
            <div class="post-meta">
                <i class="fa-solid fa-clock"></i>&nbsp;<span class="post-date">2023/12/28</span>
            </div>
            
            <div class="post-content">
                <p>android高级面试中常涉及到的java概念</p>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90">基础问题&#x2F;概念辨析</a></li>
<li><a href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6">集合框架</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8">异常</a></li>
<li><a href="#io">IO</a></li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a></li>
<li><a href="#%E5%8F%8D%E5%B0%84">反射</a></li>
<li><a href="#%E6%B3%A8%E8%A7%A3">注解</a></li>
<li><a href="#jni">JNI</a></li>
</ul>
<h1 id="基础问题-概念辨析"><a href="#基础问题-概念辨析" class="headerlink" title="基础问题&#x2F;概念辨析"></a>基础问题&#x2F;概念辨析</h1><p><strong>&#x3D;&#x3D;、equals、hashCode 区别</strong></p>
<ul>
<li>&#x3D;&#x3D; <ul>
<li>基本类型：比较数值是否相等</li>
<li>引用：比较引用变量是否相等，即比较指向的内存地址是否相等</li>
</ul>
</li>
<li>equals<ul>
<li>Object类默认实现：和&#x3D;&#x3D;一致</li>
<li>很多类实现了该方法，比较的是对象内存中的内容</li>
<li>可重写</li>
</ul>
</li>
<li>hashCode<ul>
<li>Object类默认实现：根据对象的内存地址计算</li>
<li>可重写，实践中equals和hashCode最好同时重写。因为相等的对象应该有相等的哈希码</li>
</ul>
</li>
</ul>
<p><strong>String、StringBuffer、StringBuilder 区别</strong></p>
<ul>
<li>String<ul>
<li>常量</li>
<li>对String对象的操作实际上一个不断创建新对象，将旧对象回收的过程</li>
</ul>
</li>
<li>StringBuilder<ul>
<li>变量</li>
<li>线程不安全</li>
</ul>
</li>
<li>StringBuffer<ul>
<li>变量</li>
<li>线程安全</li>
</ul>
</li>
</ul>
<p><strong>final、finally、finalize 区别</strong></p>
<ul>
<li>final<ul>
<li>修饰类，不可继承</li>
<li>修饰成员变量，不可变</li>
<li>修饰成员方法，不可重写</li>
</ul>
</li>
<li>finally<ul>
<li>与try catch共同使用，确保无论是否出现异常都执行</li>
</ul>
</li>
<li>finalize<ul>
<li>Object类的方法，默认空实现，对象被垃圾回收前会调用此方法</li>
<li>可重写</li>
</ul>
</li>
</ul>
<p><strong>Serializable、Parcelable 区别</strong></p>
<ul>
<li>Serializable<ul>
<li>java 序列化接口</li>
<li>读写中有大量临时变量，执行大量IO操作，效率低</li>
<li>对象可存储在硬盘</li>
</ul>
</li>
<li>Parcelable<ul>
<li>Android 序列化接口</li>
<li>效率高，但是用麻烦</li>
<li>对象不能存储在硬盘，只能用于内存中传递</li>
</ul>
</li>
</ul>
<p><strong>线程 run、start 区别</strong></p>
<ul>
<li>run<ul>
<li>直接调用run，没开启小城</li>
</ul>
</li>
<li>start<ul>
<li>启动线程，内部调用了run</li>
</ul>
</li>
</ul>
<p><strong>wait、notify、notifyAll、join 区别</strong></p>
<ul>
<li>wait<ul>
<li>Object类的方法</li>
<li>使当前线程等待，释放对象的锁</li>
</ul>
</li>
<li>notify<ul>
<li>Object类的方法</li>
<li>唤醒之前在该对象上调用wait等待的线程</li>
</ul>
</li>
<li>notifyAll<ul>
<li>Object类的方法</li>
<li>唤醒之前所有在该对象上调用wait等待的线程</li>
</ul>
</li>
<li>join<ul>
<li>Thread类的方法</li>
<li>等待该线程对象的结束，运行这行代码的线程进入等待状态</li>
</ul>
</li>
</ul>
<p><strong>synchronized关键字用法，对象锁、方法锁、类锁 区别</strong></p>
<p>对象锁</p>
<ul>
<li><p>在方法上使用</p>
  <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">//对象锁，锁定的是这个对象实例</span>
    <span class="hljs-comment">//多个线程调用同一个对象的同步方法会阻塞</span>
    <span class="hljs-comment">//调用不同对象的同步方法不会阻塞</span>
&#125;

<span class="hljs-comment">//等价于代码块上使用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;

    &#125;
&#125;</code></pre>
</li>
<li><p>在代码块上使用</p>
  <pre><code class="hljs java"><span class="hljs-comment">//lock对象需要放在方法外，如果放在方法内，每次调用都是不同的对象，不会有效果</span>
<span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); 

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">synchronized</span>(lock) &#123;
        <span class="hljs-comment">//锁定的是lock对象</span>
        <span class="hljs-comment">//只有一个线程能获得lock对象</span>
    &#125;
&#125;</code></pre></li>
</ul>
<p>类锁</p>
<ul>
<li>在静态方法上使用<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;

&#125;

<span class="hljs-comment">//等价于代码块上使用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">synchronized</span>(test.class) &#123;
        <span class="hljs-comment">//所有的类只有一个class对象</span>
    &#125;
&#125;</code></pre></li>
</ul>
<p>多线程同时分别访问类锁和静态锁，线程不会阻塞</p>
<p><strong>synchronized、volatile、reentrantlock 区别</strong></p>
<ul>
<li>synchronize<ul>
<li>可以修饰方法和代码块(代码块里是对象变量或者类对象)</li>
<li>本质是锁定当前变量，只有当前线程可以方法，其他线程会被阻塞</li>
<li>既能保证可见性，又能保证原子性</li>
</ul>
</li>
<li>volatile<ul>
<li>仅能修饰变量</li>
<li>本质是告诉JVM，当前变量在工作内存中的值是不确定的，需要从主存中读取</li>
<li>防止编译器优化</li>
<li>仅能保证可见性，不能保证原子性</li>
</ul>
</li>
<li>reentrantlock<ul>
<li>可重入锁，允许同一个线程多次获取同一把锁，而不会产生死锁。如果一个线程获得锁之后，可再次进入同步代码块，不会被阻塞。</li>
<li>比如递归时使用</li>
<li>获取锁和释放锁需要显式调用<pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">//同一线程重复获取同一把锁，不会死锁</span>
        innerMethod()
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">innerMethod</span><span class="hljs-params">()</span> &#123;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">//</span>
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;
&#125;</code></pre></li>
</ul>
</li>
</ul>
<p><strong>多态的理解</strong></p>
<ul>
<li>编译时多态<ul>
<li>方法的重载，方法重名，编译器根据参数类型，个数，顺序判断是哪个方法</li>
</ul>
</li>
<li>运行时多态<ul>
<li>子类重写父类的方法，具有相同的签名</li>
<li>运行时由对象的实际类型决定，而不是引用变量的类型。动态绑定<ul>
<li>引用变量的类型：编译时类型</li>
<li>对象实际类型：运行时类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p><strong>装饰者模式</strong></p>
<ul>
<li>装饰者模式允许动态的将责任附加到对象上</li>
<li>通过将输入流或者输出流传递给装饰者的构造函数，然后使用装饰者类的实例来包装原始的流</li>
<li>每个装饰者类给底层的流添加额外的功能，不需要改变原始流的结构</li>
</ul>
<pre><code class="hljs plaintext">try &#123;
    //底层节点流
    InputStream inputStream = new FileInputStream(&quot;example.txt&quot;);

    //通过内部缓冲区减少实际的磁盘或网络读写次数
    InputStream bufferedInputStream = new BufferedInputStream(inputStream);

    //提供一组用于读写基本数据类型的方法，如readInt、writeDouble
    InputStream dataInputStream = new DataInputStream(bufferedInputStream);

    int data = dataInputStream.read();
    while (data != -1) &#123;
        System.out.print((char) data);
        data = dataInputStream.read();
    &#125;

    dataInputStream.close();
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;</code></pre>

<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><strong>线程有哪些状态</strong><br>阻塞是被动的，等待是主动的</p>
<p><strong>生产者消费者简单实现</strong></p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><strong>反射为什么性能不好</strong></p>
<ul>
<li>类型检查从编译时转移到运行时</li>
<li>反射操作涉及动态创建对象，方法调用，由额外开销</li>
<li>缺乏编译时优化</li>
</ul>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h1 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h1>
            </div>
        </div>
    </div>
</main>

<script src="https://utteranc.es/client.js"
    repo="owner/repo"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  

</div>
        <div class="footer-wrapper"><footer>
    <div class="footer-container">
        <div class="footer-meta">
            
                <div class="footer-meta-copyright">
                    &copy; 2024 taninety.
                </div>
            
            
                <div class="footer-meta-licenese">
                    Licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA 4.0</a>
                </div>
            
            
                <div class="footer-meta-rss">
                    <a href="/atom.xml"><i class="fa-solid fa-rss"></i></a>
                </div>
            
        </div>
    </div>
</footer>
</div>
    </div>
</body>
</html>
