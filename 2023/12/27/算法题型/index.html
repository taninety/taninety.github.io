<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <link rel="shortcut icon" href="/images/avatar.png" type="image/x-icon" />
    <title>
        
            算法题型 |
         
        编舟
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/solid.min.css">

     
    
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXXXX"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-XXXXXXXXXXXX');
        </script>
    


<meta name="generator" content="Hexo 7.0.0"></head>

<body>
    <div class="body-container">
        <div class="header-wrapper"><header>
    <div class="header-container">
        <div class="header-menu-list">
            <ul>
            
                <li>
                    <a href="/">Home</a>
                </li>
            
                <li>
                    <a href="/about">About</a>
                </li>
            
            </ul>
        </div>
    </div>
</header>
</div>
        <div class="main-wrapper"><main>
    <div class="main-container">
        <div class="post-details">
            
            <div class="post-title">
                <h1>算法题型</h1>
            </div>
            <div class="post-meta">
                <i class="fa-solid fa-clock"></i>&nbsp;<span class="post-date">2023/12/27</span>
            </div>
            
            <div class="post-content">
                <p>在解题的过程中，重要的是理解问题、选择合适的算法思想、实现和调试</p>
<h1 id="数组与字符串"><a href="#数组与字符串" class="headerlink" title="数组与字符串"></a>数组与字符串</h1><p><strong>两数之和 (Two Sum)</strong></p>
<p>要点：哈希映射</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;
    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">complement</span> <span class="hljs-operator">=</span> target - nums[i];

        <span class="hljs-keyword">if</span> (map.containskey(complement)) &#123;
            <span class="hljs-comment">//记住数组的返回方法 new int[]&#123;1,2,3&#125;</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;map.get(complement), i&#125;;
        &#125;

        map.put(nums[i], i);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;&#125;;
&#125;</code></pre>

<p>性能分析</p>
<ul>
<li>时间复杂度 O(n)<ul>
<li>哈希表查找是O(1)</li>
</ul>
</li>
<li>空间复杂度 O(n)<ul>
<li>哈希表最坏情况是O(n)</li>
</ul>
</li>
</ul>
<p><strong>三数之和 (3Sum)</strong></p>
<p>要点：双指针</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;
    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    Arrays.sort(nums);

    <span class="hljs-comment">//至少要为后面留两个空间，用来给双指针赋值</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;
        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;
            <span class="hljs-keyword">continue</span>;
        &#125;

        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">while</span> (left &lt; right) &#123;
            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];

            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;
                result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;
                    left++;
                &#125;

                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;
                    right--;
                &#125;

                left++;
                right--;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;
                left++;
            &#125; <span class="hljs-keyword">else</span> &#123;
                right--;
            &#125;
        &#125; 
    &#125;
    <span class="hljs-keyword">return</span> result
&#125;</code></pre>

<p>性能分析</p>
<ul>
<li>时间复杂度 O(n^2)<ul>
<li>数组排序的时间复杂度是 O(nlogn)</li>
<li>外层循环和内层循环 O(n^2)</li>
</ul>
</li>
<li>空间复杂度 ?<ul>
<li>存储用的结果列表 ?</li>
</ul>
</li>
</ul>
<p><strong>反转数组 (Reverse Array)</strong></p>
<p>要点：双指针</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(intp[] nums)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];
        nums[left] = nums[right];
        nums[right] = temp;

        left++;
        right--;
    &#125;
&#125;</code></pre>

<p>性能分析</p>
<ul>
<li>时间复杂度 O(n)</li>
<li>空间复杂度 O(1)</li>
</ul>
<p><strong>移动零 (Move Zeroes)</strong></p>
<p>要点: 双指针</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;
    <span class="hljs-comment">//nonZeroIndex表示当前要存储非零值的位置</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">nonZeroIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">//i表示当前在检查的位置</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
        <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;
            nums[nonZeroIndex] = nums[i];
            nonZeroIndex++;
        &#125;
    &#125;

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nonZeroIndex; i &lt; nums.length; i++) &#123;
        nums[i] = <span class="hljs-number">0</span>;
    &#125;
&#125;</code></pre>

<p>性能分析</p>
<ul>
<li>时间复杂度 O(n)</li>
<li>空间复杂度 O(1)</li>
</ul>
<p><strong>最大子序和 (Maximum Subarray)</strong></p>
<p>要点：动态规划</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;

    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];
    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; i++) &#123;
        <span class="hljs-comment">//推导公式</span>
        <span class="hljs-comment">//dp[i-1]表示第i-1位结尾的所有情况中的最大子序和</span>
        <span class="hljs-comment">//那么dp[i]只有两种选择，i位 + dp[i-1] 或者 i位自己，取其中大的一个</span>
        <span class="hljs-comment">//之所以定义dp[i]的意义是以i结尾的最大子序列，是因为只有这样定义才能推导出dp[i+1]，并且能通过它转化成最终结果</span>
        <span class="hljs-comment">//暂时不需要完整明白怎样定义的dp，只需要记住最大子序和这个题目，dp需要这样定义</span>
        dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]);
    &#125;

    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &gt; length; i++) &#123;
        result = Math.max(result, dp[i])
    &#125;
    <span class="hljs-keyword">return</span> result;
&#125;</code></pre>

<p>性能分析</p>
<ul>
<li>时间复杂度 O(n)</li>
<li>空间复杂度 O(1)<ul>
<li>上面的解法可以优化，当前是O(n)</li>
</ul>
</li>
</ul>
<p><strong>两个数组的交集 (Intersection of Two Arrays)</strong></p>
<p>要点：哈希集合</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;
    Set&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
    Set&lt;Integer&gt; resultSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num: nums1) &#123;
        set1.add(num);
    &#125;

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num: nums2) &#123;
        <span class="hljs-keyword">if</span> (set1.contains(num)) &#123;
            resultSet.add(num);
        &#125;
    &#125;

    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[resultSet.size()];
    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num: resultSet) &#123;
        result[index++] = num;
    &#125;

    <span class="hljs-keyword">return</span> result;
&#125;</code></pre>

<p>性能分析</p>
<ul>
<li>时间复杂度 O(n1+n2)</li>
<li>空间复杂度 O()?</li>
</ul>
<p><strong>旋转数组 (Rotate Array)</strong></p>
<p>要点：三次反转</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;
    k = k % n;

    reverse(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);
    reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);
    reverse(nums, k, n - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;
    <span class="hljs-keyword">while</span> (start &lt; end) &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start++;
        end--;
    &#125;
&#125;</code></pre>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><strong>反转链表</strong></p>
<p><strong>合并两个有序链表</strong></p>
<p><strong>删除链表中的倒数第N个节点</strong></p>
<p><strong>检测环形链表</strong></p>
<p><strong>合并K个排序链表</strong></p>
<h1 id="树与图"><a href="#树与图" class="headerlink" title="树与图"></a>树与图</h1><p><strong>二叉树的遍历</strong></p>
<p><strong>二叉树的最大深度</strong></p>
<p><strong>验证二叉搜索树</strong></p>
<p><strong>最小生成树算法</strong></p>
<p><strong>拓扑排序</strong></p>
<p><strong>最短路径算法</strong></p>
<h1 id="排序与搜索"><a href="#排序与搜索" class="headerlink" title="排序与搜索"></a>排序与搜索</h1><p><strong>快速排序</strong></p>
<p><strong>归并排序</strong></p>
<p><strong>二分查找</strong></p>
<p><strong>搜索旋转排序数组</strong></p>
<p><strong>搜索插入位置</strong></p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><strong>爬楼梯</strong></p>
<p><strong>最小路径和</strong></p>
<p><strong>最小递增子序列</strong></p>
<p><strong>编辑距离</strong></p>
<p><strong>最大子序和</strong></p>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p><strong>分发饼干</strong></p>
<p><strong>跳跃游戏</strong></p>
<p><strong>买卖股票的最佳时机</strong></p>
<p><strong>划分字母区间</strong></p>
<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p><strong>全排列</strong></p>
<p><strong>组合总和</strong></p>
<p><strong>N皇后问题</strong></p>
<p><strong>解数独</strong></p>
<h1 id="数学与位运算"><a href="#数学与位运算" class="headerlink" title="数学与位运算"></a>数学与位运算</h1><p><strong>Pow(x, n)</strong></p>
<p><strong>整数反转</strong></p>
<p><strong>罗马数字转整数</strong></p>
<p><strong>两个整数之和</strong></p>
<p><strong>缺失的第一个正数</strong></p>

            </div>
        </div>
    </div>
</main>

<script src="https://utteranc.es/client.js"
    repo="owner/repo"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  

</div>
        <div class="footer-wrapper"><footer>
    <div class="footer-container">
        <div class="footer-meta">
            
                <div class="footer-meta-copyright">
                    &copy; 2023 taninety.
                </div>
            
            
                <div class="footer-meta-licenese">
                    Licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA 4.0</a>
                </div>
            
            
                <div class="footer-meta-rss">
                    <a href="/atom.xml"><i class="fa-solid fa-rss"></i></a>
                </div>
            
        </div>
    </div>
</footer>
</div>
    </div>
</body>
</html>
