<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <link rel="shortcut icon" href="/images/avatar.png" type="image/x-icon" />
    <title>
        
            算法基础 |
         
        编舟
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/solid.min.css">

     
    
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXXXX"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-XXXXXXXXXXXX');
        </script>
    


<meta name="generator" content="Hexo 7.0.0"></head>

<body>
    <div class="body-container">
        <div class="header-wrapper"><header>
    <div class="header-container">
        <div class="header-menu-list">
            <ul>
            
                <li>
                    <a href="/">Home</a>
                </li>
            
                <li>
                    <a href="/about">About</a>
                </li>
            
            </ul>
        </div>
    </div>
</header>
</div>
        <div class="main-wrapper"><main>
    <div class="main-container">
        <div class="post-details">
            
            <div class="post-title">
                <h1>算法基础</h1>
            </div>
            <div class="post-meta">
                <i class="fa-solid fa-clock"></i>&nbsp;<span class="post-date">2023/12/27</span>
            </div>
            
            <div class="post-content">
                <ul>
<li><a href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">排序算法</a></li>
<li><a href="#%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">搜索算法</a></li>
<li><a href="#%E5%9B%BE%E7%AE%97%E6%B3%95">图算法</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95">字符串匹配算法</a></li>
<li><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97">位运算</a></li>
<li><a href="#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95">哈希算法</a></li>
</ul>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>全部都用从小到大排序举例</p>
<p><strong>冒泡排序</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> array.length;
    <span class="hljs-comment">//每一轮确认一个数的位置，放到最后，只需要确认n-1轮，第1个位置不用确认</span>
    <span class="hljs-comment">//i表示这是第几轮冒泡，隐含的意思是，最后部分已经成功冒泡了几位</span>
    <span class="hljs-comment">//最后一位最开始是 n - 1，冒泡不包含最后一位所以是 &lt;，不包含 =</span>
    <span class="hljs-comment">//冒泡成功 i 位之后，最后一位变成 n - 1 - i</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;
        <span class="hljs-comment">//每一轮会把最大的元素交换到最后一个，每次比较j和j+1，所以j只需要比较到倒数第二个即可</span>
        <span class="hljs-comment">//j的意思是当前正在冒泡的元素</span>
        <span class="hljs-comment">//每轮的比较是冒泡元素和下一个元素</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - <span class="hljs-number">1</span> - i; j++) &#123;   
            <span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>]) &#123;
                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[j];
                array[j] = array[j + <span class="hljs-number">1</span>];
                array[j + <span class="hljs-number">1</span>] = temp;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>性能分析</p>
<ul>
<li>平均时间复杂度 O(n^2)<ul>
<li>最好 O(n) 基本有序</li>
<li>最差 O(n^2) 乱序</li>
</ul>
</li>
<li>空间复杂度 O(1)</li>
<li>稳定性 稳定</li>
<li>使用场景 小规模或基本有序数据</li>
</ul>
<p><strong>选择排序</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> array.length

    <span class="hljs-comment">//每一轮选择一个最小的数，放在开始位置，最后一个位置不用确认，所以只需要n-1轮</span>
    <span class="hljs-comment">//i的意思是第几轮选择。隐含的意思是，最开始部分已经选择成功了几位</span>
    <span class="hljs-comment">//i的意思是本次要防止选择元素的位置</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;
        <span class="hljs-comment">//确定第i个位置应放什么数，通过从i之后的位置中筛选最小的值，i上的值也要参与比较</span>
        <span class="hljs-comment">//j的意思是选择的起点，即i的下一位，每次都是到结束</span>
        <span class="hljs-comment">//每轮的比较是当前最小元素和其后元素依次比较</span>
        <span class="hljs-comment">//排序的所有最外层都只有n - 1轮。另外写算法最好不要用 &lt;=，要让边界有一致性</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;
            <span class="hljs-keyword">if</span> (array[j] &lt; array[minIndex]) &#123;
                minIndex = j;
            &#125;
        &#125;

        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[minIndex];
        array[minIndex] = array[i];
        array[i] = temp
    &#125;
&#125;</code></pre>

<p>性能分析</p>
<ul>
<li>平均时间复杂度 O(n^2) <ul>
<li>最好 O(n^2) </li>
<li>最差 O(n^2)</li>
</ul>
</li>
<li>空间复杂度 O(1)</li>
<li>稳定性 不稳定</li>
<li>使用场景 小规模，或对稳定性不敏感情况</li>
</ul>
<p><strong>插入排序</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> array.length;

    <span class="hljs-comment">//i的意思是当前要往前插入的元素，所以要从第二个位置开始</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> array[i]
        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;

        <span class="hljs-comment">//前半部分总是有序的</span>
        <span class="hljs-comment">//j的意思是当前要拦截插入元素的位置</span>
        <span class="hljs-comment">//每轮的比较是要插入的元素和已排序的元素比较，像是一次对抗</span>
        <span class="hljs-comment">//但是是虚拟对抗，对抗失败的后退一位，但是我不前进</span>
        <span class="hljs-comment">//不过要限定j的范围是0，如果再小会数组越界</span>
        <span class="hljs-comment">//循环结束时，j的意义比较失败的元素，所以j的下一位是该放元素的位置</span>
        <span class="hljs-comment">//有点像足球运动员带球过人，冒泡才是真正的带球过人，插入其实是模拟过人战术</span>
        <span class="hljs-keyword">while</span> (j &gt;=<span class="hljs-number">0</span> &amp;&amp; array[j] &gt; key) &#123;
            array[j + <span class="hljs-number">1</span>] = array[j];
            j--;
        &#125;

        array[j + <span class="hljs-number">1</span>] = key;
    &#125;
&#125;</code></pre>

<p>性能分析</p>
<ul>
<li>平均时间复杂度 O(n^2) <ul>
<li>最好 O(n) </li>
<li>最差 O(n^2)</li>
</ul>
</li>
<li>空间复杂度 O(1)</li>
<li>稳定性 稳定</li>
<li>使用场景</li>
</ul>
<p><strong>希尔排序</strong></p>
<p>插入排序的改进版本</p>
<pre><code class="hljs java"></code></pre>

<p><strong>归并排序</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> array.length;
    <span class="hljs-comment">//递归的结束是长度小于等于1，只要长度还大于1，就还可以继续拆分</span>
    <span class="hljs-comment">//长度大于1，就还需要排序，所以肯定要进行下面的步骤</span>
    <span class="hljs-keyword">if</span> (length &gt; <span class="hljs-number">1</span>) &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> length / <span class="hljs-number">2</span>;

        <span class="hljs-type">int</span>[] leftArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[mid];
        <span class="hljs-type">int</span>[] rightArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length - mid];

        <span class="hljs-comment">//源到目标，把数组拆成两半</span>
        <span class="hljs-comment">//分界线是mid，即0~mid-1，mid~length-1</span>
        <span class="hljs-comment">//如果元素是10，mid=5，即0~4，5~9</span>
        <span class="hljs-comment">//如果元素是9，mid=4, 即0~3，4~8，后半部分比前半部分多一个</span>
        <span class="hljs-comment">//之所以要复制成额外的数组，是因为原数组要在合并的时候当作存储用</span>
        <span class="hljs-comment">//System.arraycopy(array, 0, leftArray, 0, mid);</span>
        <span class="hljs-comment">//System.arraycopy(array, mid, rightArray, 0, length - mid);</span>

        <span class="hljs-comment">//手动实现复制数组</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mid; i++) &#123;
            leftArray[i] = array[i];
        &#125;

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; length - mid; j++) &#123;
            rightArray[j] = array[mid + j];
        &#125;

        <span class="hljs-comment">//拆分完递归排序两组，递归的次数是 O(logn)</span>
        mergeSort(leftArray);
        mergeSort(rightArray);

        <span class="hljs-comment">//合并的过程是精髓 O(n)</span>
        merge(array, leftArray, rightArray);
    &#125;
&#125;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span>[] leftArray, <span class="hljs-type">int</span>[] rightArray)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">leftLength</span> <span class="hljs-operator">=</span> leftArray.length;
    <span class="hljs-type">int</span> <span class="hljs-variable">rightLength</span> <span class="hljs-operator">=</span> rightArray.length;
    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;

    <span class="hljs-comment">//边界条件的本质还是让数组不要越界</span>
    <span class="hljs-comment">//i的意思是左数组的当前元素</span>
    <span class="hljs-comment">//j的意思是右数组的当前元素</span>
    <span class="hljs-comment">//k的意思是合并数组当前要插入的位置</span>
    <span class="hljs-comment">//下面的写法很经典，最后能背下来</span>
    <span class="hljs-keyword">while</span> (i &lt; leftLength &amp;&amp; j &lt; rightLength) &#123;
        <span class="hljs-keyword">if</span> (leftArray[i] &lt;= rightArray[j]) &#123;
            array[k++] = leftArray[i++];
        &#125; <span class="hljs-keyword">else</span> &#123;
            array[k++] = rightArray[j++];
        &#125;
    &#125;

    <span class="hljs-comment">//循环结束后一定是有一个数组结束了</span>
    <span class="hljs-comment">//那要做的是另一个数组循环完</span>
    <span class="hljs-keyword">while</span> (i &lt; leftLength) &#123;
        array[k++] = leftArray[i++];
    &#125;

    <span class="hljs-keyword">while</span> (j &lt; rightLength) &#123;
        array[k++] = rightArray[j++];
    &#125;
&#125;</code></pre>

<p>性能分析</p>
<ul>
<li>平均时间复杂度 O(nlogn) <ul>
<li>最好 O(nlogn)  </li>
<li>最差 O(nlogn)</li>
</ul>
</li>
<li>空间复杂度 O(n)</li>
<li>稳定性 稳定</li>
<li>使用场景</li>
</ul>
<p><strong>快速排序</strong></p>
<p><strong>堆排序</strong></p>
<p>选择排序的改进版本</p>
<p><strong>计数排序</strong></p>
<p>计数排序本质上是一种特殊的桶排序</p>
<p><strong>桶排序</strong></p>
<p><strong>基数排序</strong></p>
<p>基数排序也是一种桶排序</p>
<h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><p><strong>顺序搜索</strong></p>
<p><strong>二分搜索</strong></p>
<h1 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h1><p><strong>深度优先搜索</strong></p>
<p>前序遍历&#x2F;中序遍历&#x2F;后序遍历</p>
<p><strong>广度优先搜索</strong></p>
<p>层序遍历</p>
<p><strong>最短路径算法（Dijkstra）</strong></p>
<p><strong>最短路径算法（Bellman-Ford）</strong></p>
<p><strong>最小生成树算法（Prim）</strong></p>
<p><strong>最小生成树算法（Kruskal）</strong></p>
<p><strong>拓扑排序（Topological Sort）</strong></p>
<h1 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h1><p><strong>暴力匹配算法</strong></p>
<p><strong>KMP算法</strong></p>
<p><strong>Boyer-Moore算法</strong></p>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p><strong>位与&#x2F;位或&#x2F;位异或</strong></p>
<p><strong>位左移&#x2F;位右移</strong></p>
<p><strong>位的反转&#x2F;位的计数</strong></p>
<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p><strong>散列函数</strong></p>

            </div>
        </div>
    </div>
</main>

<script src="https://utteranc.es/client.js"
    repo="owner/repo"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  

</div>
        <div class="footer-wrapper"><footer>
    <div class="footer-container">
        <div class="footer-meta">
            
                <div class="footer-meta-copyright">
                    &copy; 2024 taninety.
                </div>
            
            
                <div class="footer-meta-licenese">
                    Licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA 4.0</a>
                </div>
            
            
                <div class="footer-meta-rss">
                    <a href="/atom.xml"><i class="fa-solid fa-rss"></i></a>
                </div>
            
        </div>
    </div>
</footer>
</div>
    </div>
</body>
</html>
